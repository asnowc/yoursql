## API Report File for "@asla/yoursql"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class ColumnMeta<T> {
    constructor(type: CustomDbType<T> | (new (...args: any[]) => T),
    sqlType: string,
    notNull?: boolean,
    isArray?: boolean,
    sqlDefault?: string | undefined);
    checkValue(value: any): boolean;
    readonly isArray: boolean;
    readonly notNull: boolean;
    readonly sqlDefault?: string | undefined;
    readonly sqlType: string;
    // (undocumented)
    readonly type: CustomDbType<T> | (new (...args: any[]) => T);
}

// @public
export type ColumnsSelectAs<T extends TableType> = {
    [key in keyof T]?: boolean | string;
};

// @public
export type ColumnsSelected<T extends TableType> = ColumnsSelectAs<T> | "*";

// @public (undocumented)
export interface CurrentGroupBy<T extends TableType> extends CurrentOrderBy<T> {
    // (undocumented)
    groupBy(columns: string | string[]): CurrentHaving<T>;
}

// @public (undocumented)
export interface CurrentHaving<T extends TableType> extends CurrentOrderBy<T> {
    // (undocumented)
    having(param: WhereParam | (() => WhereParam)): CurrentLimit<T>;
}

// @public (undocumented)
export interface CurrentLimit<T extends TableType> extends SqlQueryStatement<T> {
    // (undocumented)
    limit(limit?: number, offset?: number): SqlQueryStatement<T>;
}

// @public (undocumented)
export interface CurrentOrderBy<T extends TableType> extends CurrentLimit<T> {
    // (undocumented)
    orderBy(param: OrderByParam): CurrentLimit<T>;
}

// @public (undocumented)
export interface CurrentWhere<T extends TableType> extends CurrentGroupBy<T> {
    // (undocumented)
    where(param: WhereParam | (() => WhereParam)): CurrentGroupBy<T>;
}

// @public
export class CustomDbType<T> {
    constructor(is: (this: CustomDbType<T>, value: any) => boolean, name: string);
    // (undocumented)
    static readonly bigint: CustomDbType<bigint>;
    // (undocumented)
    static readonly boolean: CustomDbType<boolean>;
    // (undocumented)
    readonly is: (this: CustomDbType<T>, value: any) => boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly number: CustomDbType<number>;
    // (undocumented)
    static readonly string: CustomDbType<string>;
}

// @public
export class DbTable<T extends TableType> extends SqlSelectable<T> {
    constructor(name: string, columns: readonly (keyof T)[]);
    // (undocumented)
    readonly name: string;
    // (undocumented)
    toSelect(): string;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export class DbTableQuery<T extends TableType = Record<string, any>, C extends TableType = Partial<T>> extends DbTable<T> {
    constructor(name: string, columns: readonly string[], statement: SqlValuesCreator);
    // (undocumented)
    delete(option?: DeleteOption): string;
    // (undocumented)
    deleteWithResult<R extends ColumnsSelected<T>>(returns?: ColumnsSelected<T> | "*", option?: DeleteOption): SqlQueryStatement<SelectColumns<T, R>>;
    // (undocumented)
    fromAs(as?: string): Selection_2;
    // (undocumented)
    insert(values: C[] | SqlQueryStatement<C>, option?: InsertOption<T>): string;
    // (undocumented)
    insertWithResult<R extends ColumnsSelected<T>>(values: C[] | SqlQueryStatement<C>, returns: R, option?: InsertOption<T>): SqlQueryStatement<SelectColumns<T, R>>;
    // (undocumented)
    update(values: UpdateRowValue<T>, option?: UpdateOption): string;
    // (undocumented)
    updateWithResult<R extends ColumnsSelected<T>>(values: UpdateRowValue<T>, returns: R, option?: UpdateOption): SqlQueryStatement<SelectColumns<T, R>>;
}

// @public (undocumented)
export interface DeleteOption {
    // (undocumented)
    where?: WhereParam;
}

// @public
export function getObjectListKeys(objectList: any[], keepUndefinedKey?: boolean): Set<string>;

// @public
export function having(condition?: WhereParam | (() => WhereParam), type?: "AND" | "OR"): string;

// @public
export type InferQueryResult<T> = T extends SqlSelectable<infer P> ? (P extends TableType ? P : never) : never;

// @public (undocumented)
export type InferTableDefined<T extends TableDefined> = {
    [key in keyof T]: T[key] extends ColumnMeta<infer P> ? P : unknown;
};

// @public (undocumented)
export interface InsertOption<T extends object> {
    // (undocumented)
    conflict?: (keyof T)[];
    // (undocumented)
    updateValues?: {
        [key in keyof T]?: undefined | SqlRaw | T[key];
    };
    // (undocumented)
    where?: WhereParam;
}

// @public (undocumented)
export type JsObjectMapSql = Map<new (...args: any[]) => any, SqlValueEncoder>;

// @public (undocumented)
export type ManualType = "bigint" | "number" | "string" | "boolean" | "object" | (new (...args: any[]) => any);

// @public (undocumented)
export type OrderBehavior = {
    key: string;
    asc: boolean;
    nullLast?: boolean;
};

// @public
export function orderBy(by: OrderByParam | (() => OrderByParam)): string;

// @public (undocumented)
export type OrderByParam = string | (string | OrderBehavior)[] | Record<string, boolean | `${OrderValue} ${"NULLS FIRST" | "NULLS LAST"}`>;

// @public (undocumented)
export type OrderValue = "ASC" | "DESC";

// @public
export const pgSqlTransformer: JsObjectMapSql;

// @public (undocumented)
export type PickColumn<T extends {
    [key: string]: any;
}, Rq extends keyof T = keyof T, Pa extends Exclude<keyof T, Rq> = never> = {
    [key in Rq as null extends T[key] ? key : never]?: T[key];
} & {
    [key in Rq as null extends T[key] ? never : key]: T[key];
} & {
    [key in Pa]?: T[key];
};

// Warning: (ae-forgotten-export) The symbol "StringOnly" needs to be exported by the entry point index.d.ts
//
// @public
export type SelectColumns<T extends TableType, R extends ColumnsSelected<T>> = R extends "*" ? T : R extends ColumnsSelectAs<T> ? {
    [key in keyof T as R[key] extends true ? key : StringOnly<R[key]>]: T[key];
} : never;

// @public
export function selectColumns(columns: string[] | Record<string, string | boolean>): string;

// @public (undocumented)
class Selection_2 {
    constructor(selectable: SqlSelectable<any> | string, as?: string);
    // (undocumented)
    crossJoin(selectable: SqlSelectable<any>, as?: string | undefined): Selection_2;
    // (undocumented)
    static from(selectable: SqlSelectable<any> | string, as?: string): Selection_2;
    // (undocumented)
    from(selectable: SqlSelectable<any> | string, as?: string): Selection_2;
    // (undocumented)
    fullJoin(selectable: SqlSelectable<any>, as: string | undefined, on: string): Selection_2;
    // (undocumented)
    innerJoin(selectable: SqlSelectable<any>, as: string | undefined, on: string): Selection_2;
    // (undocumented)
    leftJoin(selectable: SqlSelectable<any>, as: string | undefined, on: string): Selection_2;
    // (undocumented)
    naturalJoin(selectable: SqlSelectable<any>, as?: string | undefined): Selection_2;
    // (undocumented)
    rightJoin(selectable: SqlSelectable<any>, as: string | undefined, on: string): Selection_2;
    // (undocumented)
    select<T extends TableType = TableType>(columns: "*" | string[]): CurrentWhere<T>;
    // (undocumented)
    select<T extends TableType = TableType>(columns: {
        [key in keyof T]: string | boolean;
    }): CurrentWhere<T>;
    // (undocumented)
    select<T extends TableType = TableType>(columns: "*" | string[] | TableType): CurrentWhere<T>;
    // (undocumented)
    toString(): string;
}
export { Selection_2 as Selection }

// @public
export class SqlQueryStatement<T extends TableType = TableType> extends SqlSelectable<T> {
    constructor(sql: string, columns: readonly string[]);
    constructor(sql: SqlQueryStatement);
    // (undocumented)
    toSelect(): string;
    // (undocumented)
    toString(): string;
}

// @public
export class SqlRaw<T = any> {
    protected [SQL_RAW]: T;
    constructor(value: string);
    // (undocumented)
    toString(): string;
}

// @public
export abstract class SqlSelectable<T extends TableType> {
    protected [SQL_SELECTABLE]: T;
    constructor(columns: ArrayLike<string> | Iterable<string>);
    readonly columns: readonly string[];
    abstract toSelect(): string;
    abstract toString(): string;
}

// @public (undocumented)
export type SqlValueEncoder<T = any> = (this: SqlValuesCreator, value: T) => string;

// @public (undocumented)
export interface SqlValueFn {
    (value: any, expectType?: ManualType): string;
}

// @public
export class SqlValuesCreator {
    constructor(map?: JsObjectMapSql);
    // (undocumented)
    static create(map?: JsObjectMapSql): SqlValuesCreator & SqlValueFn;
    createValues<T extends {}>(asName: string, values: T[], valuesTypes: Record<string, string | {
        sqlType: string;
        sqlDefault?: string;
    }>): SqlSelectable<T>;
    // (undocumented)
    protected defaultObject(value: object): string;
    getObjectType(value: object): SqlValueEncoder;
    objectListToValuesList<T extends object>(objectList: T[], keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined;
    }, keepUndefinedKey?: boolean): string;
    objectToValues<T extends object>(object: T, keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined;
    }): string;
    setTransformer<T>(type: new (...args: any[]) => T, transformer?: SqlValueEncoder): void;
    static string(value: string): string;
    toSqlStr(value: any, expectType?: ManualType): string;
    toValues(values: readonly any[]): string;
}

// @public (undocumented)
export type TableDefined = {
    [key: string]: ColumnMeta<any>;
};

// @public (undocumented)
export type TableType = {
    [key: string]: any;
};

// @public (undocumented)
export class TypeChecker<T> {
    constructor(map: Map<string, ColumnMeta<any>>);
    // (undocumented)
    check(value: {
        [key: string]: any;
    }): T;
    // (undocumented)
    checkList(value: any[]): T[];
}

// @public (undocumented)
export interface UpdateOption {
    // (undocumented)
    where?: WhereParam;
}

// @public (undocumented)
export type UpdateRowValue<T extends object> = {
    [key in keyof T]?: T[key] | SqlRaw;
};

// @public
export function where(condition?: WhereParam | (() => WhereParam), type?: "AND" | "OR"): string;

// @public (undocumented)
export type WhereParam = string | string[];

// @public
export class YourTable<T extends TableType = TableType, C extends TableType = T> extends DbTableQuery<T, C> {
    constructor(name: string, define: TableDefined, sqlValue: SqlValuesCreator);
    // (undocumented)
    createTypeChecker<T>(keys: readonly string[]): TypeChecker<T>;
    // (undocumented)
    getColumnMeta(name: keyof T): ColumnMeta<unknown>;
}

// Warning: (ae-forgotten-export) The symbol "TypeMapDefined" needs to be exported by the entry point index.d.ts
//
// @public
export class YourTypeMap<M extends TypeMapDefined> {
    constructor(typeMap?: M);
    // Warning: (ae-forgotten-export) The symbol "InferTypeMapDefined" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T extends TypeMapDefined>(rawTypeMap?: T): YourTypeMap<{
        [key in keyof T]: InferTypeMapDefined<T[key]>;
    }>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T][]>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T][] | null>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull: true, defaultValue?: string): ColumnMeta<T[]>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull?: boolean, defaultValue?: string): ColumnMeta<T[] | null>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T]>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T] | null>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull: true, defaultValue?: string): ColumnMeta<T>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull?: boolean, defaultValue?: string): ColumnMeta<T | null>;
}

// (No @packageDocumentation comment for this package)

```
