## API Report File for "@asla/yoursql"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
type AssertJsType = "bigint" | "number" | "string" | "boolean" | "object" | (new (...args: any[]) => any);

// @public (undocumented)
interface ChainConflictDo<T extends TableType = {}> {
    // (undocumented)
    doNotThing(): ChainModifyReturning<T>;
    doUpdate(set: Constructable<string | {
        [key in keyof T]?: string;
    }>): ChainModifyWhere<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
interface ChainModifyReturning<T extends TableType = {}> extends SqlStatement {
    // (undocumented)
    returning(columns: "*"): SqlStatementDataset<T>;
    // (undocumented)
    returning(columns: Constructable<SelectParam>): SqlStatementDataset<Record<string, any>>;
    // (undocumented)
    returning<R extends TableType>(columns: Constructable<SelectParam>): SqlStatementDataset<R>;
}

// @public (undocumented)
interface ChainModifyWhere<T extends TableType = {}> extends ChainModifyReturning<T> {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainModifyReturning<T>;
}

// @public (undocumented)
interface ChainOnConflict<T extends TableType = {}> extends ChainModifyReturning<T> {
    // (undocumented)
    onConflict(option: Constructable<readonly (keyof T)[] | string>): ChainConflictDo<T>;
}

// @public (undocumented)
interface ChainSelectGroupBy<T extends TableType> extends ChainSelectOrderBy<T> {
    // (undocumented)
    groupBy(columns: string | string[]): ChainSelectHaving<T>;
}

// @public (undocumented)
interface ChainSelectHaving<T extends TableType> extends ChainSelectOrderBy<T> {
    // (undocumented)
    having(param: Constructable<ConditionParam | void>): ChainSelectLimit<T>;
}

// @public (undocumented)
interface ChainSelectLimit<T extends TableType> extends SqlStatementDataset<T> {
    // (undocumented)
    limit(limit?: number | bigint, offset?: number | bigint): SqlStatementDataset<T>;
}

// @public (undocumented)
interface ChainSelectOrderBy<T extends TableType> extends ChainSelectLimit<T> {
    // (undocumented)
    orderBy(param: Constructable<OrderByParam | void>): ChainSelectLimit<T>;
}

// @public (undocumented)
interface ChainSelectWhere<T extends TableType> extends ChainSelectGroupBy<T> {
    // (undocumented)
    where(param: Constructable<ConditionParam | void>): ChainSelectGroupBy<T>;
}

declare namespace client {
    export {
        ParallelQueryError,
        ConnectionNotAvailableError,
        DbConnection,
        TransactionMode,
        DbTransaction,
        DbQueryPool,
        SingleQueryResult,
        QueryRowsResult,
        MultipleQueryResult,
        QueryResult,
        DbQuery,
        DbCursorOption,
        DbCursor,
        DbPoolConnection,
        DbPoolTransaction
    }
}

// @public
class ColumnMeta<T> {
    constructor(type: CustomDbType<T> | (new (...args: any[]) => T),
    sqlType: string,
    notNull?: boolean,
    isArray?: boolean,
    sqlDefault?: string | undefined);
    checkValue(value: any): boolean;
    readonly isArray: boolean;
    readonly notNull: boolean;
    readonly sqlDefault?: string | undefined;
    readonly sqlType: string;
    // (undocumented)
    readonly type: CustomDbType<T> | (new (...args: any[]) => T);
}

// @public (undocumented)
type ColumnToValueConfig = {
    sqlType?: string;
    assertJsType?: AssertJsType;
};

// @public (undocumented)
type ConditionParam = string | string[];

// @public (undocumented)
class ConnectionNotAvailableError extends Error {
    constructor(message: string);
}

// @public (undocumented)
type Constructable<T> = T | (() => T);

declare namespace core {
    export {
        v,
        pgSqlTransformer,
        SqlRaw,
        JsObjectMapSql,
        SqlValueEncoder,
        AssertJsType,
        SqlValueFn,
        SqlValuesCreator,
        ColumnToValueConfig,
        PickColumn,
        UpdateRowValue,
        OrderValue,
        TableType,
        DbTable,
        DeleteOption,
        SqlSelectChain,
        Selection_2 as Selection,
        SqlStatement,
        SqlSelectable,
        SqlStatementDataset,
        ChainSelectLimit,
        ChainSelectOrderBy,
        ChainSelectHaving,
        ChainSelectGroupBy,
        ChainSelectWhere,
        ChainModifyReturning,
        ChainModifyWhere,
        ChainConflictDo,
        ChainOnConflict,
        SqlTextStatementDataset,
        InferQueryResult,
        DbTableQuery,
        getObjectListKeys,
        where,
        having,
        selectColumns,
        orderBy,
        Constructable,
        ConditionParam,
        SelectParam,
        OrderBehavior,
        OrderByParam,
        TypeChecker,
        ColumnMeta,
        YourTypeMap,
        CustomDbType,
        TableDefined,
        InferTableDefined,
        YourTable
    }
}

// @public
class CustomDbType<T> {
    constructor(is: (this: CustomDbType<T>, value: any) => boolean, name: string);
    // (undocumented)
    static readonly bigint: CustomDbType<bigint>;
    // (undocumented)
    static readonly boolean: CustomDbType<boolean>;
    // (undocumented)
    readonly is: (this: CustomDbType<T>, value: any) => boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly number: CustomDbType<number>;
    // (undocumented)
    static readonly string: CustomDbType<string>;
}

// @public
interface DbConnection extends DbQuery, AsyncDisposable {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
abstract class DbCursor<T> {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<T>, void, unknown>;
    abstract close(): Promise<void>;
    abstract read(maxSize?: number): Promise<T[]>;
}

// @public (undocumented)
interface DbCursorOption {
    // (undocumented)
    defaultSize?: number;
}

// @public
class DbPoolConnection extends DbQuery {
    // (undocumented)
    [Symbol.dispose](): void;
    constructor(conn: DbConnection, onRelease: () => void);
    // (undocumented)
    begin(mode?: TransactionMode): Promise<void>;
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: {
        toString(): string;
    }): Promise<T>;
    // (undocumented)
    query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T = any>(sql: {
        toString(): string;
    }): Promise<QueryRowsResult<T>>;
    release(): void;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
}

// @public
class DbPoolTransaction extends DbQuery implements DbTransaction {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    constructor(connect: () => Promise<DbPoolConnection>, mode?: TransactionMode | undefined);
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    readonly mode?: TransactionMode | undefined;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlStatementDataset<T>): Promise<T>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: {
        toString(): string;
    }): Promise<T>;
    // (undocumented)
    query<T extends object = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T extends object = any>(sql: {
        toString(): string;
    }): Promise<QueryRowsResult<T>>;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
    // (undocumented)
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public
abstract class DbQuery {
    abstract multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlStatementDataset<T>): Promise<T>;
    abstract multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: {
        toString(): string;
    }): Promise<T>;
    multipleQueryRows<T extends any[] = any[]>(sql: SqlStatementDataset<T>): Promise<T[]>;
    multipleQueryRows<T extends any[] = any[]>(sql: {
        toString(): string;
    }): Promise<T[]>;
    abstract query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    abstract query<T = any>(sql: {
        toString(): string;
    }): Promise<QueryRowsResult<T>>;
    queryCount(sql: string | {
        toString(): string;
    }): Promise<number>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: SqlStatementDataset<T>, key: K): Promise<Map<T[K], T>>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: {
        toString(): string;
    }, key: K): Promise<Map<T[K], T>>;
    queryRows<T = any>(sql: SqlStatementDataset<T>): Promise<T[]>;
    queryRows<T = any>(sql: {
        toString(): string;
    }): Promise<T[]>;
}

// @public
interface DbQueryPool extends DbQuery {
    // (undocumented)
    begin(mode?: TransactionMode): DbTransaction;
    // (undocumented)
    connect(): Promise<DbPoolConnection>;
    // (undocumented)
    cursor<T extends {}>(sql: SqlStatementDataset<T>): Promise<DbCursor<T>>;
    // (undocumented)
    cursor<T>(sql: {
        toString(): string;
    }, option?: DbCursorOption): Promise<DbCursor<T>>;
    // (undocumented)
    idleCount: number;
    // (undocumented)
    totalCount: number;
}

// @public
class DbTable<T extends TableType> {
    constructor(name: string);
    // (undocumented)
    delete(option?: DeleteOption): ChainModifyWhere<T>;
    // (undocumented)
    fromAs(as?: string): Selection_2;
    insert(columns: string, values: Constructable<string>): ChainOnConflict<T>;
    // (undocumented)
    readonly name: string;
    select(columns: "*", as?: string): ChainSelectWhere<T>;
    select(columns: Constructable<Record<string, boolean | string> | string>, as?: string): ChainSelectWhere<Record<string, any>>;
    select<R extends {}>(columns: Constructable<{
        [key in keyof R]: boolean | string;
    } | string>, as?: string): ChainSelectWhere<R>;
    // (undocumented)
    toSelect(): string;
    update(values: Constructable<{
        [key in keyof T]?: string;
    } | string>): ChainModifyWhere<T>;
}

// @public (undocumented)
class DbTableQuery<T extends TableType = Record<string, any>, C extends TableType = Partial<T>> extends DbTable<T> {
    constructor(name: string, statement: SqlValuesCreator);
    // (undocumented)
    insert(values: Constructable<UpdateRowValue<C> | UpdateRowValue<C>[]>): ChainOnConflict<T>;
    // (undocumented)
    insert(columns: string, values: Constructable<string>): ChainOnConflict<T>;
    updateFrom(values: Constructable<UpdateRowValue<T>>): ChainModifyWhere<T>;
}

// @public
interface DbTransaction extends DbQuery, AsyncDisposable {
    commit(): Promise<void>;
    rollback(): Promise<void>;
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
interface DeleteOption {
    // (undocumented)
    where?: Constructable<ConditionParam | void>;
}

// @public
function getObjectListKeys(objectList: any[], keepUndefinedKey?: boolean): Set<string>;

// @public
function having(conditions?: Constructable<ConditionParam | void>, type?: "AND" | "OR"): string;

// @public
type InferQueryResult<T> = T extends SqlStatementDataset<infer P> ? P : never;

// @public (undocumented)
type InferTableDefined<T extends TableDefined> = {
    [key in keyof T]: T[key] extends ColumnMeta<infer P> ? P : unknown;
};

// @public
type JsObjectMapSql = Map<new (...args: any[]) => any, SqlValueEncoder>;

// @public (undocumented)
type MultipleQueryResult = SingleQueryResult[];

// @public (undocumented)
type OrderBehavior = {
    key: string;
    asc: boolean;
    nullLast?: boolean;
};

// @public
function orderBy(by?: Constructable<OrderByParam | void>): string;

// @public (undocumented)
type OrderByParam = string | (string | OrderBehavior)[] | Record<string, boolean | `${OrderValue} ${"NULLS FIRST" | "NULLS LAST"}`>;

// @public (undocumented)
type OrderValue = "ASC" | "DESC";

// @public (undocumented)
class ParallelQueryError extends Error {
    constructor();
}

// @public
const pgSqlTransformer: JsObjectMapSql;

// @public (undocumented)
type PickColumn<T extends {
    [key: string]: any;
}, Rq extends keyof T = keyof T, Pa extends Exclude<keyof T, Rq> = never> = {
    [key in Rq as null extends T[key] ? key : never]?: T[key];
} & {
    [key in Rq as null extends T[key] ? never : key]: T[key];
} & {
    [key in Pa]?: T[key];
};

// @public (undocumented)
type QueryResult = MultipleQueryResult | SingleQueryResult;

// @public (undocumented)
interface QueryRowsResult<T = any> extends SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows: T[];
}

// @public (undocumented)
function selectColumns(columns: Constructable<SelectParam>): string;

// @public (undocumented)
class Selection_2 {
    constructor(selectable: Constructable<SqlSelectable | string>, as?: string);
    // (undocumented)
    crossJoin(selectable: Constructable<SqlSelectable | string>, as?: string | undefined): Selection_2;
    // (undocumented)
    static from(selectable: Constructable<SqlSelectable | string>, as?: string): Selection_2;
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, as?: string): Selection_2;
    // (undocumented)
    fullJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    innerJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    leftJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    naturalJoin(selectable: Constructable<SqlSelectable | string>, as?: string | undefined): Selection_2;
    // (undocumented)
    rightJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    select<T extends TableType = Record<string, any>>(columns: "*"): ChainSelectWhere<T>;
    select(columns: Constructable<SelectParam>): ChainSelectWhere<Record<string, any>>;
    select<T extends TableType>(columns: Constructable<{
        [key in keyof T]: string | boolean;
    } | string>): ChainSelectWhere<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
type SelectParam = string | string[] | Record<string, string | boolean>;

// @public (undocumented)
interface SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows?: any[];
}

// @public
class SqlRaw<T = any> extends String {
    protected [SQL_RAW]: T;
}

// @public
interface SqlSelectable {
    toSelect(): string;
}

// @public
class SqlSelectChain<T extends TableType> extends SqlTextStatementDataset<T> implements ChainSelectWhere<T> {
    // (undocumented)
    groupBy(columns: string | string[]): ChainSelectHaving<T>;
    // (undocumented)
    having(param?: Constructable<ConditionParam | void>): ChainSelectLimit<T>;
    // (undocumented)
    limit(limit?: number, offset?: number): SqlStatementDataset<T>;
    // (undocumented)
    orderBy(param?: Constructable<OrderByParam | void>): ChainSelectLimit<T>;
    // (undocumented)
    where(param?: Constructable<ConditionParam | void>): ChainSelectGroupBy<T>;
}

// @public (undocumented)
abstract class SqlStatement {
    abstract toString(): string;
}

// @public (undocumented)
abstract class SqlStatementDataset<T> extends SqlStatement implements SqlSelectable {
    toSelect(): string;
}

// @public (undocumented)
class SqlTextStatementDataset<T> extends SqlStatementDataset<T> {
    constructor(sql: string);
    // (undocumented)
    readonly sql: string;
    // (undocumented)
    toString(): string;
}

// @public
type SqlValueEncoder<T = any> = (this: SqlValuesCreator, value: T) => string;

// @public (undocumented)
type SqlValueFn = SqlValuesCreator & {
    (value: any, assertType?: AssertJsType): string;
};

// @public
class SqlValuesCreator {
    constructor(map?: JsObjectMapSql);
    // (undocumented)
    static create(map?: JsObjectMapSql): SqlValueFn;
    createValues<T extends {}>(asName: string, values: T[], valuesTypes: Record<string, string | {
        sqlType: string;
        sqlDefault?: string;
        assertJsType?: AssertJsType;
    }>): SqlStatementDataset<T>;
    // (undocumented)
    protected defaultObject(value: object): string;
    getClassType(value: object): undefined | (new (...args: unknown[]) => unknown);
    // @deprecated (undocumented)
    getObjectType(value: object): SqlValueEncoder;
    objectListToValuesList<T extends object>(objectList: T[], keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined | ColumnToValueConfig;
    }, keepUndefinedKey?: boolean): string;
    objectToValues<T extends object>(object: T, keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined | ColumnToValueConfig;
    }): string;
    setTransformer(type: new (...args: any[]) => any, encoder?: SqlValueEncoder): void;
    // (undocumented)
    setTransformer(map: JsObjectMapSql): void;
    static string(value: string): string;
    toSqlStr(value: any, assertJsType?: AssertJsType): string;
    toValues(values: readonly any[]): string;
}

// @public (undocumented)
type TableDefined = {
    [key: string]: ColumnMeta<any>;
};

// @public (undocumented)
type TableType = {
    [key: string]: any;
};

// @public (undocumented)
type TransactionMode = "SERIALIZABLE" | "REPEATABLE READ" | "READ COMMITTED" | "READ UNCOMMITTED";

// @public (undocumented)
class TypeChecker<T> {
    constructor(map: Map<string, ColumnMeta<any>>);
    // (undocumented)
    check(value: {
        [key: string]: any;
    }): T;
    // (undocumented)
    checkList(value: any[]): T[];
}

// @public (undocumented)
type UpdateRowValue<T extends object> = {
    [key in keyof T]?: T[key] | SqlRaw;
};

// @public
const v: SqlValueFn;

// @public
function where(conditions?: Constructable<ConditionParam | void>, type?: "AND" | "OR"): string;

// @public
class YourTable<T extends TableType = TableType, C extends TableType = T> extends DbTableQuery<T, C> {
    constructor(name: string, define: TableDefined, sqlValue: SqlValuesCreator);
    // (undocumented)
    readonly columns: readonly string[];
    // (undocumented)
    createTypeChecker<T>(keys: readonly string[]): TypeChecker<T>;
    // (undocumented)
    getColumnMeta(name: keyof T): ColumnMeta<unknown>;
}

// Warning: (ae-forgotten-export) The symbol "TypeMapDefined" needs to be exported by the entry point index.d.ts
//
// @public
class YourTypeMap<M extends TypeMapDefined> {
    constructor(typeMap?: M);
    // Warning: (ae-forgotten-export) The symbol "InferTypeMapDefined" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T extends TypeMapDefined>(rawTypeMap?: T): YourTypeMap<{
        [key in keyof T]: InferTypeMapDefined<T[key]>;
    }>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T][]>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T][] | null>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull: true, defaultValue?: string): ColumnMeta<T[]>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull?: boolean, defaultValue?: string): ColumnMeta<T[] | null>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T]>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T] | null>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull: true, defaultValue?: string): ColumnMeta<T>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull?: boolean, defaultValue?: string): ColumnMeta<T | null>;
}

// (No @packageDocumentation comment for this package)

```
