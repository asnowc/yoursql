## API Report File for "@asla/yoursql"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
type AssertJsType = "bigint" | "number" | "string" | "boolean" | "object" | (new (...args: any[]) => any);

// @public (undocumented)
interface ChainAfterConflict {
    // (undocumented)
    doNotThing(): ChainInsertReturning;
    // (undocumented)
    doUpdate(set: Constructable<string | readonly string[] | Record<string, string>>): ChainInsertReturning;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
interface ChainCTE {
    // (undocumented)
    as(statement: Constructable<string>): ChainCTE;
    // (undocumented)
    as(name: string, statement: Constructable<string>): ChainCTE;
    // (undocumented)
    deleteFrom: DeleteFromSqlGenerator;
    // (undocumented)
    insertInto: InsertIntoSqlGenerator;
    // (undocumented)
    select: SelectSqlGenerator;
    // (undocumented)
    toString(): string;
    // (undocumented)
    update: UpdateSqlGenerator;
}

// @public (undocumented)
interface ChainDelete extends ChainDeleteAfterUsing {
    // (undocumented)
    using(...table: (Constructable<string> | {
        selectable: Constructable<string>;
        as: string;
    })[]): ChainDeleteAfterUsing;
}

// @public (undocumented)
interface ChainDeleteAfterUsing extends ChainDeleteReturning {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainDeleteReturning;
}

// Warning: (ae-forgotten-export) The symbol "ChainModifyReturning" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ChainDeleteReturning extends ChainModifyReturning {
}

// @public (undocumented)
interface ChainInsert extends ChainInsertAfterValues {
    // (undocumented)
    select(statement: Constructable<string>): ChainInsertAfterValues;
    // (undocumented)
    values(statement: Constructable<string | readonly string[]>): ChainInsertAfterValues;
}

// @public (undocumented)
interface ChainInsertAfterValues extends ChainInsertReturning {
    // (undocumented)
    onConflict(columns: string | string[]): ChainAfterConflict;
}

// @public (undocumented)
interface ChainInsertReturning extends ChainModifyReturning {
}

// @public (undocumented)
interface ChainSelect<T extends TableType> {
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, option?: SelectAsNameOption): ChainSelectAfterFirstFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterFirstFrom<T extends TableType> extends ChainSelectAfterFrom<T> {
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, option?: SelectAsNameOption): ChainSelectAfterFirstFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterFrom<T extends TableType> extends ChainSelectAfterJoin<T> {
    // (undocumented)
    crossJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectAsNameOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    fullJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    innerJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    leftJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    naturalJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectAsNameOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    rightJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterGroupBy<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    having(param: Constructable<ConditionParam | void>): ChainSelectAfterHaving<T>;
}

// @public (undocumented)
interface ChainSelectAfterHaving<T extends TableType> extends ChainSelectAfterOrderBy<T> {
    // (undocumented)
    orderBy(param: Constructable<OrderByParam | void>): ChainSelectAfterOrderBy<T>;
}

// @public (undocumented)
interface ChainSelectAfterJoin<T extends TableType> extends ChainSelectAfterWhere<T> {
    // (undocumented)
    where(param: Constructable<ConditionParam | void>): ChainSelectAfterWhere<T>;
}

// @public (undocumented)
interface ChainSelectAfterLimit<T extends TableType> extends SqlStatementDataset<T> {
}

// @public (undocumented)
interface ChainSelectAfterOrderBy<T extends TableType> extends SqlStatementDataset<T> {
    // (undocumented)
    limit(limit?: number | bigint, offset?: number | bigint): ChainSelectAfterLimit<T>;
}

// @public (undocumented)
interface ChainSelectAfterWhere<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    groupBy(columns?: string | string[]): ChainSelectAfterGroupBy<T>;
}

// @public (undocumented)
interface ChainUpdate<T extends TableType = TableType> {
    // (undocumented)
    set(value: Constructable<{
        [key in keyof T]?: string;
    } | string>): ChainUpdateAfterSet;
}

// @public (undocumented)
interface ChainUpdateAfterForm extends ChainUpdateReturning {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainUpdateReturning;
}

// @public (undocumented)
interface ChainUpdateAfterSet extends ChainUpdateAfterForm {
    // (undocumented)
    from(...table: (Constructable<string> | {
        selectable: Constructable<string>;
        as: string;
    })[]): ChainUpdateAfterForm;
}

// @public (undocumented)
interface ChainUpdateReturning extends ChainModifyReturning {
}

declare namespace client {
    export {
        ParallelQueryError,
        ConnectionNotAvailableError,
        DbConnection,
        TransactionMode,
        DbTransaction,
        DbPool,
        SqlLike,
        sqlLikeToString,
        isSqlTemplate,
        SingleQueryResult,
        QueryRowsResult,
        MultipleQueryResult,
        DbQueryBase,
        QueryInput,
        QueryDataInput,
        MultipleQueryInput,
        DbQuery,
        DbCursorOption,
        DbCursor,
        DbPoolConnection,
        DbPoolTransactionOption,
        DbPoolTransaction,
        ExecutableSQL,
        QueryableDataSQL,
        DbQueryPool
    }
}

// @public
class ColumnMeta<T> {
    constructor(type: CustomDbType<T> | (new (...args: any[]) => T),
    sqlType: string,
    notNull?: boolean,
    isArray?: boolean,
    sqlDefault?: string | undefined);
    checkValue(value: any): boolean;
    readonly isArray: boolean;
    readonly notNull: boolean;
    readonly sqlDefault?: string | undefined;
    readonly sqlType: string;
    // (undocumented)
    readonly type: CustomDbType<T> | (new (...args: any[]) => T);
}

// @public (undocumented)
type ColumnToValueConfig = {
    sqlType?: string;
    assertJsType?: AssertJsType;
    sqlDefault?: string;
};

// @public (undocumented)
type ConditionParam = string | readonly string[];

// @public (undocumented)
class ConnectionNotAvailableError extends Error {
    constructor(message: string);
}

// @public (undocumented)
type Constructable<T> = T | (() => T);

declare namespace core {
    export {
        v,
        pgSqlTransformer,
        TemplateSqlStatement as ValueSqlTemplate,
        JsObjectMapSql,
        SqlValueEncoder,
        SqlValueFn,
        SqlValuesCreator,
        SqlValuesTextData,
        SqlExplicitValuesStatement,
        AssertJsType,
        ColumnToValueConfig,
        ObjectToValueKeys,
        SqlStatement,
        SqlSelectable,
        SqlStatementDataset,
        SqlTextStatementDataset,
        InferQueryResult,
        SqlTemplate,
        SqlTextTemplate,
        select,
        orderBy,
        SelectSqlGenerator,
        SelectAsNameOption,
        ChainSelect,
        ChainSelectAfterFirstFrom,
        SelectJoinOption,
        ChainSelectAfterFrom,
        ChainSelectAfterJoin,
        ChainSelectAfterWhere,
        ChainSelectAfterGroupBy,
        ChainSelectAfterHaving,
        ChainSelectAfterOrderBy,
        ChainSelectAfterLimit,
        OrderValue,
        OrderBehavior,
        OrderByParam,
        insertInto,
        InsertIntoSqlGenerator,
        ChainAfterConflict,
        ChainInsert,
        ChainInsertAfterValues,
        ChainInsertReturning,
        update,
        UpdateOption,
        UpdateSqlGenerator,
        ChainUpdate,
        ChainUpdateAfterSet,
        ChainUpdateAfterForm,
        ChainUpdateReturning,
        deleteFrom,
        DeleteOption,
        DeleteFromSqlGenerator,
        ChainDelete,
        ChainDeleteAfterUsing,
        ChainDeleteReturning,
        withAs,
        withRecursiveAs,
        ChainCTE,
        selectColumns,
        ConditionParam,
        Constructable,
        SelectParam,
        ToInsertType,
        UpdateRowValue,
        TableType,
        TypeChecker,
        ColumnMeta,
        YourTypeMap,
        CustomDbType,
        TableDefined,
        InferTableDefined,
        YourTable
    }
}

// @public
class CustomDbType<T> {
    constructor(is: (this: CustomDbType<T>, value: any) => boolean, name: string);
    // (undocumented)
    static readonly bigint: CustomDbType<bigint>;
    // (undocumented)
    static readonly boolean: CustomDbType<boolean>;
    // (undocumented)
    readonly is: (this: CustomDbType<T>, value: any) => boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly number: CustomDbType<number>;
    // (undocumented)
    static readonly string: CustomDbType<string>;
}

// @public
interface DbConnection extends DbQuery, AsyncDisposable {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
abstract class DbCursor<T> {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<T, undefined, void>;
    abstract close(): Promise<void>;
    abstract read(maxSize?: number): Promise<T[]>;
}

// @public (undocumented)
interface DbCursorOption {
    // (undocumented)
    defaultSize?: number;
}

// @public
interface DbPool {
    // (undocumented)
    begin(mode?: TransactionMode): DbTransaction;
    // (undocumented)
    connect(): Promise<DbPoolConnection>;
    // (undocumented)
    cursor<T extends {}>(sql: SqlStatementDataset<T>): Promise<DbCursor<T>>;
    // (undocumented)
    cursor<T>(sql: SqlLike, option?: DbCursorOption): Promise<DbCursor<T>>;
    // (undocumented)
    idleCount: number;
    // (undocumented)
    totalCount: number;
}

// @public
class DbPoolConnection extends DbQuery {
    // (undocumented)
    [Symbol.dispose](): void;
    constructor(conn: DbQueryBase, onRelease: (conn: DbQueryBase) => void);
    // (undocumented)
    begin(mode?: TransactionMode): Promise<void>;
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    execute(sql: QueryInput | MultipleQueryInput): Promise<void>;
    // @deprecated (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    // (undocumented)
    query<T extends MultipleQueryResult = MultipleQueryResult>(sql: MultipleQueryInput): Promise<T>;
    // (undocumented)
    query<T = any>(sql: QueryDataInput<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T = any>(sql: QueryInput): Promise<QueryRowsResult<T>>;
    release(): void;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
}

// @public
class DbPoolTransaction extends DbQuery implements DbTransaction {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    constructor(connect: () => Promise<DbPoolConnection>, option?: TransactionMode | DbPoolTransactionOption);
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    execute(sql: QueryInput | MultipleQueryInput): Promise<void>;
    // (undocumented)
    readonly mode?: TransactionMode;
    // @deprecated (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    // (undocumented)
    query<T extends MultipleQueryResult = MultipleQueryResult>(sql: MultipleQueryInput): Promise<T>;
    // (undocumented)
    query<T extends object = any>(sql: QueryDataInput<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T extends object = any>(sql: QueryInput): Promise<QueryRowsResult<T>>;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
    // (undocumented)
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
type DbPoolTransactionOption = {
    errorRollback?: boolean;
    mode?: TransactionMode;
};

// @public
abstract class DbQuery {
    // (undocumented)
    abstract execute(sql: QueryInput | MultipleQueryInput): Promise<void>;
    // @deprecated (undocumented)
    abstract multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    // @deprecated
    multipleQueryRows<T extends any[] = any[]>(sql: SqlLike | SqlLike[]): Promise<T[]>;
    // (undocumented)
    abstract query<T extends MultipleQueryResult = MultipleQueryResult>(sql: MultipleQueryInput): Promise<T>;
    // (undocumented)
    abstract query<T = any>(sql: QueryDataInput<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    abstract query<T = any>(sql: QueryInput): Promise<QueryRowsResult<T>>;
    queryCount(sql: QueryInput): Promise<number>;
    queryFirstRow<T = any>(sql: QueryDataInput<T>): Promise<T>;
    // (undocumented)
    queryFirstRow<T = any>(sql: QueryInput): Promise<T>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: QueryDataInput<T>, key: K): Promise<Map<T[K], T>>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: QueryInput, key: K): Promise<Map<T[K], T>>;
    queryRows<T = any>(sql: QueryDataInput<T>): Promise<T[]>;
    queryRows<T = any>(sql: QueryInput): Promise<T[]>;
}

// @public
interface DbQueryBase {
    execute(sql: SqlLike | SqlLike[]): Promise<void>;
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    query<T = any>(sql: SqlLike): Promise<QueryRowsResult<T>>;
    query<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike[]): Promise<T>;
    // (undocumented)
    query(sql: SqlLike[] | SqlLike): Promise<unknown[] | unknown>;
}

// @public
abstract class DbQueryPool extends DbQuery implements DbPool {
    // (undocumented)
    abstract begin(mode?: TransactionMode): DbTransaction;
    // (undocumented)
    abstract connect(): Promise<DbPoolConnection>;
    // (undocumented)
    createExecutableSQL(statement: SqlLike): ExecutableSQL<void>;
    // (undocumented)
    createQueryableSQL<Raw>(statement: SqlStatementDataset<Raw>): QueryableDataSQL<Raw, void>;
    // (undocumented)
    createQueryableSQL<Raw>(statement: SqlLike): QueryableDataSQL<Raw, void>;
    // (undocumented)
    createQueryableSQL<T extends SqlStatementDataset<any>, Res>(statement: T, transform: (queryable: DbQueryPool, statement: T) => Promise<Res>): QueryableDataSQL<InferQueryResult<T>, Awaited<Res>>;
    // (undocumented)
    createQueryableSQL<Raw, Res>(statement: SqlLike, transform: (queryable: DbQueryPool, statement: SqlLike) => Promise<Res>): QueryableDataSQL<Raw, Res>;
    // (undocumented)
    abstract cursor<T extends {}>(sql: SqlStatementDataset<T>): Promise<DbCursor<T>>;
    // (undocumented)
    abstract cursor<T>(sql: SqlLike, option?: DbCursorOption): Promise<DbCursor<T>>;
    abstract idleCount: number;
    abstract totalCount: number;
}

// @public
interface DbTransaction extends DbQuery, AsyncDisposable {
    commit(): Promise<void>;
    rollback(): Promise<void>;
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
const deleteFrom: DeleteFromSqlGenerator;

// @public (undocumented)
interface DeleteFromSqlGenerator {
    // (undocumented)
    (table: string, option?: DeleteOption): ChainDelete;
}

// @public (undocumented)
interface DeleteOption {
    // (undocumented)
    as?: string;
}

// @public (undocumented)
interface ExecutableSQL<T = unknown> {
    // (undocumented)
    genSql(): string;
    // (undocumented)
    then(resolve: (data: T) => void, reject: () => void): void;
}

// @public
type InferQueryResult<T> = T extends SqlStatementDataset<infer P> ? P : never;

// @public (undocumented)
type InferTableDefined<T extends TableDefined> = {
    [key in keyof T]: T[key] extends ColumnMeta<infer P> ? P : unknown;
};

// @public (undocumented)
const insertInto: InsertIntoSqlGenerator;

// @public (undocumented)
interface InsertIntoSqlGenerator {
    // (undocumented)
    (target: string): ChainInsert;
    // (undocumented)
    (table: string, columns: readonly string[]): ChainInsert;
}

// @public (undocumented)
function isSqlTemplate(obj: any): obj is SqlTemplate;

// @public
type JsObjectMapSql = Map<new (...args: any[]) => any, SqlValueEncoder>;

// @public (undocumented)
type MultipleQueryInput = SqlLike[] | (() => SqlLike[]);

// @public (undocumented)
type MultipleQueryResult = SingleQueryResult[];

// @public (undocumented)
type ObjectToValueKeys<T extends {}> = readonly string[] | ({
    [key in keyof T as key extends string ? key : never]?: string | ColumnToValueConfig;
} & {
    [key: string]: string | undefined | ColumnToValueConfig;
});

// @public (undocumented)
type OrderBehavior = {
    key: string;
    asc: boolean;
    nullLast?: boolean;
    target?: undefined;
} | {
    key: string;
    target: OrderByValue;
};

// @public
function orderBy(by?: Constructable<OrderByParam | void>): string;

// @public (undocumented)
type OrderByParam = string | OrderBehavior | (string | OrderBehavior)[];

// @public (undocumented)
type OrderValue = "ASC" | "DESC";

// @public (undocumented)
class ParallelQueryError extends Error {
    constructor();
}

// @public
const pgSqlTransformer: JsObjectMapSql;

// @public (undocumented)
interface QueryableDataSQL<Raw, Res = QueryRowsResult<Raw>> extends ExecutableSQL<Res> {
    // (undocumented)
    cursor(): Promise<DbCursor<Raw>>;
    // (undocumented)
    query(): Promise<QueryRowsResult<Raw>>;
    // (undocumented)
    queryCount(): Promise<number>;
    // (undocumented)
    queryFirstRow(): Promise<Raw>;
    // (undocumented)
    queryMap<K>(key: string): Promise<Map<K, Raw>>;
    // (undocumented)
    queryRows(): Promise<Raw[]>;
}

// @public (undocumented)
type QueryDataInput<T> = SqlStatementDataset<T> | (() => SqlStatementDataset<T>);

// @public (undocumented)
type QueryInput = SqlLike | (() => SqlLike);

// @public (undocumented)
interface QueryRowsResult<T = any> extends SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows: T[];
}

// @public (undocumented)
const select: SelectSqlGenerator;

// @public (undocumented)
type SelectAsNameOption = {
    as?: string;
};

// @public (undocumented)
function selectColumns(columns: Constructable<SelectParam>): string;

// @public (undocumented)
type SelectJoinOption = SelectAsNameOption & {
    on?: Constructable<ConditionParam>;
};

// @public (undocumented)
type SelectParam = string | readonly string[] | Record<string, string | boolean>;

// @public (undocumented)
interface SelectSqlGenerator {
    // (undocumented)
    (columns?: undefined | ""): ChainSelect<{}>;
    // (undocumented)
    <T extends TableType>(columns: "*"): ChainSelect<T>;
    // (undocumented)
    <T extends TableType>(columns: Constructable<{
        [key in keyof T]: string | boolean;
    }>): ChainSelect<T>;
    // (undocumented)
    <T extends TableType>(columns: Constructable<string | string[]>): ChainSelect<T>;
    // (undocumented)
    <T extends TableType>(columns: Constructable<string | readonly string[] | {
        readonly [key in keyof T]: string | boolean;
    }>): ChainSelect<T>;
}

// @public (undocumented)
interface SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows?: any[];
}

// @public (undocumented)
class SqlExplicitValuesStatement {
    constructor(columns: readonly string[], text: string);
    // (undocumented)
    columns: readonly string[];
    // (undocumented)
    readonly text: string;
    // (undocumented)
    toSelect(name: string): string;
}

// @public (undocumented)
type SqlLike = {
    genSql(): string;
} | SqlTemplate | string;

// @public
function sqlLikeToString(sqlLike: SqlLike): string;

// @public
interface SqlSelectable {
    toSelect(asName?: string): string;
}

// @public (undocumented)
abstract class SqlStatement {
    abstract genSql(): string;
    toString(): string;
}

// @public (undocumented)
abstract class SqlStatementDataset<T> extends SqlStatement implements SqlSelectable {
    __infer(v: T): never;
    toSelect(asName?: string): string;
}

// @public (undocumented)
interface SqlTemplate<T extends readonly any[] = readonly unknown[]> {
    // (undocumented)
    readonly args: T;
    // (undocumented)
    readonly templates: readonly string[];
    // (undocumented)
    toTextArgs(): string[];
}

// @public (undocumented)
class SqlTextStatementDataset<T> extends SqlStatementDataset<T> {
    constructor(sql: string);
    // (undocumented)
    genSql(): string;
    // (undocumented)
    readonly sql: string;
}

// @public (undocumented)
interface SqlTextTemplate {
    // (undocumented)
    readonly textArgs: readonly string[];
    // (undocumented)
    readonly textTemplate: string;
}

// @public
type SqlValueEncoder<T = any> = (this: SqlValuesCreator, value: T) => string;

// @public (undocumented)
type SqlValueFn = SqlValuesCreator & {
    (value: any, assertType?: AssertJsType): string;
};

// @public
class SqlValuesCreator {
    constructor(map?: JsObjectMapSql);
    // (undocumented)
    static create(map?: JsObjectMapSql): SqlValueFn;
    createExplicitValues<T extends object>(objectList: T, columns?: ObjectToValueKeys<T>): SqlExplicitValuesStatement;
    // (undocumented)
    createExplicitValues<T extends object>(objectList: T[], columns?: ObjectToValueKeys<T>): SqlExplicitValuesStatement;
    createImplicitValues<T extends object>(objectList: T, columns?: ObjectToValueKeys<T>): SqlValuesTextData;
    // (undocumented)
    createImplicitValues<T extends object>(objectList: T[], columns?: ObjectToValueKeys<T>): SqlValuesTextData;
    // (undocumented)
    protected defaultObject(value: object): string;
    // @alpha (undocumented)
    gen(split: TemplateStringsArray, ...values: any[]): TemplateSqlStatement;
    getClassType(value: object): undefined | (new (...args: unknown[]) => unknown);
    setTransformer(type: new (...args: any[]) => any, encoder?: SqlValueEncoder): void;
    // (undocumented)
    setTransformer(map: JsObjectMapSql): void;
    static string(value: string): string;
    toSqlStr(value: any, assertJsType?: AssertJsType): string;
    toValues(values: readonly any[]): string;
}

// @public (undocumented)
type SqlValuesTextData = {
    columns: string[];
    text: string;
};

// @public (undocumented)
type TableDefined = {
    [key: string]: ColumnMeta<any>;
};

// @public (undocumented)
type TableType = {
    [key: string]: any;
};

// @alpha (undocumented)
class TemplateSqlStatement extends SqlStatement implements SqlTemplate, SqlTextTemplate {
    constructor(v: (value: unknown) => string, templates: readonly string[], values: readonly unknown[]);
    // (undocumented)
    readonly args: readonly unknown[];
    // (undocumented)
    genSql(): string;
    // (undocumented)
    readonly templates: readonly string[];
    // (undocumented)
    get textArgs(): readonly string[];
    // (undocumented)
    get textTemplate(): string;
    // (undocumented)
    toTextArgs(): string[];
}

// @public
type ToInsertType<T extends {
    [key: string]: any;
}, Pa extends keyof T = never> = {
    [key in keyof T as key extends Pa ? never : null extends T[key] ? never : key]: T[key];
} & {
    [key in keyof T as null extends T[key] ? key : key extends Pa ? key : never]?: T[key];
};

// @public (undocumented)
type TransactionMode = "SERIALIZABLE" | "REPEATABLE READ" | "READ COMMITTED" | "READ UNCOMMITTED";

// @public (undocumented)
class TypeChecker<T> {
    constructor(map: Map<string, ColumnMeta<any>>);
    // (undocumented)
    check(value: {
        [key: string]: any;
    }): T;
    // (undocumented)
    checkList(value: any[]): T[];
}

// @public (undocumented)
const update: UpdateSqlGenerator;

// @public (undocumented)
interface UpdateOption {
    // (undocumented)
    as?: string;
}

// @public (undocumented)
type UpdateRowValue<T extends object> = {
    [key in keyof T]?: T[key] | String;
};

// @public (undocumented)
interface UpdateSqlGenerator {
    // (undocumented)
    <T extends TableType>(table: string, options?: UpdateOption): ChainUpdate<T>;
}

// @public
const v: SqlValueFn;

// @public (undocumented)
function withAs(statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withAs(name: string, statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withRecursiveAs(statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withRecursiveAs(name: string, statement: Constructable<string>): ChainCTE;

// @public
class YourTable<T extends TableType = TableType> {
    constructor(name: string, define: TableDefined);
    // (undocumented)
    readonly columns: readonly string[];
    // (undocumented)
    createTypeChecker<T>(keys: readonly string[]): TypeChecker<T>;
    // (undocumented)
    getColumnMeta(name: keyof T): ColumnMeta<unknown>;
    // (undocumented)
    readonly name: string;
}

// Warning: (ae-forgotten-export) The symbol "TypeMapDefined" needs to be exported by the entry point index.d.ts
//
// @public
class YourTypeMap<M extends TypeMapDefined> {
    constructor(typeMap?: M);
    // Warning: (ae-forgotten-export) The symbol "InferTypeMapDefined" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T extends TypeMapDefined>(rawTypeMap?: T): YourTypeMap<{
        [key in keyof T]: InferTypeMapDefined<T[key]>;
    }>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T][]>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T][] | null>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull: true, defaultValue?: string): ColumnMeta<T[]>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull?: boolean, defaultValue?: string): ColumnMeta<T[] | null>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T]>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T] | null>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull: true, defaultValue?: string): ColumnMeta<T>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull?: boolean, defaultValue?: string): ColumnMeta<T | null>;
}

// Warnings were encountered during analysis:
//
// src/sql_gen/statement/select_chain.ts:109:20 - (ae-forgotten-export) The symbol "OrderByValue" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
