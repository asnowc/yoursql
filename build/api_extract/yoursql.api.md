## API Report File for "@asla/yoursql"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
type AssertJsType = "bigint" | "number" | "string" | "boolean" | "object" | (new (...args: any[]) => any);

// @public (undocumented)
interface ChainAfterConflictDo<T extends TableType = {}> {
    // (undocumented)
    doNotThing(): ChainModifyReturning<T>;
    doUpdate(set: Constructable<string | {
        [key in keyof T]?: string;
    }>): ChainModifyReturning<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
interface ChainDelete<T extends TableType = {}> extends ChainModifyReturning<T> {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainModifyReturning<T>;
}

// @public (undocumented)
interface ChainInsert<T extends TableType = {}> extends ChainModifyReturning<T> {
    // (undocumented)
    onConflict(option: Constructable<readonly (keyof T)[] | string>): ChainAfterConflictDo<T>;
}

// @public (undocumented)
interface ChainModifyReturning<T extends TableType = {}> extends SqlStatement {
    // (undocumented)
    returning(columns: "*"): SqlStatementDataset<T>;
    // (undocumented)
    returning(columns: Constructable<SelectParam>): SqlStatementDataset<Record<string, any>>;
    // (undocumented)
    returning<R extends TableType>(columns: Constructable<SelectParam>): SqlStatementDataset<R>;
}

// @public (undocumented)
interface ChainSelect<T extends TableType> extends ChainSelectAfterWhere<T> {
    // (undocumented)
    where(param: Constructable<ConditionParam | void>): ChainSelectAfterWhere<T>;
}

// @public (undocumented)
interface ChainSelectAfterGroupBy<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    having(param: Constructable<ConditionParam | void>): ChainSelectAfterHaving<T>;
    // (undocumented)
    orderBy(param: Constructable<OrderByParam | void>): ChainSelectAfterOrderBy<T>;
}

// @public (undocumented)
interface ChainSelectAfterHaving<T extends TableType> extends ChainSelectAfterOrderBy<T> {
    // (undocumented)
    orderBy(param: Constructable<OrderByParam | void>): ChainSelectAfterOrderBy<T>;
}

// @public (undocumented)
interface ChainSelectAfterLimit<T extends TableType> extends SqlStatementDataset<T> {
}

// @public (undocumented)
interface ChainSelectAfterOrderBy<T extends TableType> extends SqlStatementDataset<T> {
    // (undocumented)
    limit(limit?: number | bigint, offset?: number | bigint): ChainSelectAfterLimit<T>;
}

// @public (undocumented)
interface ChainSelectAfterWhere<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    groupBy(columns: string | string[]): ChainSelectAfterGroupBy<T>;
}

// @public (undocumented)
interface ChainUpdate<T extends TableType = {}> extends ChainModifyReturning<T> {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainModifyReturning<T>;
}

declare namespace client {
    export {
        ParallelQueryError,
        ConnectionNotAvailableError,
        DbConnection,
        TransactionMode,
        DbTransaction,
        DbQueryPool,
        StringLike,
        SingleQueryResult,
        QueryRowsResult,
        MultipleQueryResult,
        QueryResult,
        DbQueryBase,
        DbQuery,
        DbCursorOption,
        DbCursor,
        DbPoolConnection,
        DbPoolTransactionOption,
        DbPoolTransaction
    }
}

// @public
class ColumnMeta<T> {
    constructor(type: CustomDbType<T> | (new (...args: any[]) => T),
    sqlType: string,
    notNull?: boolean,
    isArray?: boolean,
    sqlDefault?: string | undefined);
    checkValue(value: any): boolean;
    readonly isArray: boolean;
    readonly notNull: boolean;
    readonly sqlDefault?: string | undefined;
    readonly sqlType: string;
    // (undocumented)
    readonly type: CustomDbType<T> | (new (...args: any[]) => T);
}

// @public (undocumented)
type ColumnToValueConfig = {
    sqlType?: string;
    assertJsType?: AssertJsType;
};

// @public (undocumented)
type ConditionParam = string | string[];

// @public (undocumented)
class ConnectionNotAvailableError extends Error {
    constructor(message: string);
}

// @public (undocumented)
type Constructable<T> = T | (() => T);

declare namespace core {
    export {
        v,
        pgSqlTransformer,
        JsObjectMapSql,
        SqlValueEncoder,
        AssertJsType,
        SqlValueFn,
        SqlValuesCreator,
        ColumnToValueConfig,
        PickColumn,
        ToInsertType,
        UpdateRowValue,
        OrderValue,
        TableType,
        DbTable,
        DeleteOption,
        SqlSelectChain,
        Selection_2 as Selection,
        SqlStatement,
        SqlSelectable,
        SqlStatementDataset,
        SqlTextStatementDataset,
        InferQueryResult,
        ChainModifyReturning,
        ChainAfterConflictDo,
        ChainInsert,
        ChainUpdate,
        ChainDelete,
        ChainSelect,
        ChainSelectAfterWhere,
        ChainSelectAfterGroupBy,
        ChainSelectAfterHaving,
        ChainSelectAfterOrderBy,
        ChainSelectAfterLimit,
        DbTableQuery,
        getObjectListKeys,
        where,
        having,
        selectColumns,
        orderBy,
        Constructable,
        ConditionParam,
        SelectParam,
        OrderBehavior,
        OrderByParam,
        TypeChecker,
        ColumnMeta,
        YourTypeMap,
        CustomDbType,
        TableDefined,
        InferTableDefined,
        YourTable
    }
}

// @public
class CustomDbType<T> {
    constructor(is: (this: CustomDbType<T>, value: any) => boolean, name: string);
    // (undocumented)
    static readonly bigint: CustomDbType<bigint>;
    // (undocumented)
    static readonly boolean: CustomDbType<boolean>;
    // (undocumented)
    readonly is: (this: CustomDbType<T>, value: any) => boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly number: CustomDbType<number>;
    // (undocumented)
    static readonly string: CustomDbType<string>;
}

// @public
interface DbConnection extends DbQuery, AsyncDisposable {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
abstract class DbCursor<T> {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<T, undefined, void>;
    abstract close(): Promise<void>;
    abstract read(maxSize?: number): Promise<T[]>;
}

// @public (undocumented)
interface DbCursorOption {
    // (undocumented)
    defaultSize?: number;
}

// @public
class DbPoolConnection extends DbQuery {
    // (undocumented)
    [Symbol.dispose](): void;
    constructor(conn: DbQueryBase, onRelease: (conn: DbQueryBase) => void);
    // (undocumented)
    begin(mode?: TransactionMode): Promise<void>;
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: StringLike): Promise<T>;
    // (undocumented)
    query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T = any>(sql: StringLike): Promise<QueryRowsResult<T>>;
    release(): void;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
}

// @public
class DbPoolTransaction extends DbQuery implements DbTransaction {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    constructor(connect: () => Promise<DbPoolConnection>, option?: TransactionMode | DbPoolTransactionOption);
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    readonly mode?: TransactionMode;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlStatementDataset<T>): Promise<T>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: StringLike): Promise<T>;
    // (undocumented)
    query<T extends object = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T extends object = any>(sql: StringLike): Promise<QueryRowsResult<T>>;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
    // (undocumented)
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
type DbPoolTransactionOption = {
    errorRollback?: boolean;
    mode?: TransactionMode;
};

// @public
abstract class DbQuery implements DbQueryBase {
    // (undocumented)
    abstract multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: StringLike): Promise<T>;
    multipleQueryRows<T extends any[] = any[]>(sql: SqlStatementDataset<T>): Promise<T[]>;
    multipleQueryRows<T extends any[] = any[]>(sql: StringLike): Promise<T[]>;
    // (undocumented)
    abstract query<T = any>(sql: StringLike): Promise<QueryRowsResult<T>>;
    queryCount(sql: string | StringLike): Promise<number>;
    queryFirstRow<T = any>(sql: SqlStatementDataset<T>): Promise<T>;
    // (undocumented)
    queryFirstRow<T = any>(sql: StringLike): Promise<T>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: SqlStatementDataset<T>, key: K): Promise<Map<T[K], T>>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: StringLike, key: K): Promise<Map<T[K], T>>;
    queryRows<T = any>(sql: SqlStatementDataset<T>): Promise<T[]>;
    queryRows<T = any>(sql: StringLike): Promise<T[]>;
}

// @public (undocumented)
interface DbQueryBase {
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: StringLike): Promise<T>;
    query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    query<T = any>(sql: StringLike): Promise<QueryRowsResult<T>>;
}

// @public
interface DbQueryPool extends DbQuery {
    // (undocumented)
    begin(mode?: TransactionMode): DbTransaction;
    // (undocumented)
    connect(): Promise<DbPoolConnection>;
    // (undocumented)
    cursor<T extends {}>(sql: SqlStatementDataset<T>): Promise<DbCursor<T>>;
    // (undocumented)
    cursor<T>(sql: StringLike, option?: DbCursorOption): Promise<DbCursor<T>>;
    // (undocumented)
    idleCount: number;
    // (undocumented)
    totalCount: number;
}

// @public
class DbTable<T extends TableType> {
    constructor(name: string);
    // (undocumented)
    delete(option?: DeleteOption): ChainDelete<T>;
    // (undocumented)
    fromAs(as?: string): Selection_2;
    insert(columns: string, values: Constructable<string>): ChainInsert<T>;
    // (undocumented)
    readonly name: string;
    select(columns: "*", as?: string): ChainSelect<T>;
    select(columns: Constructable<{
        [key in keyof T]?: string | boolean;
    } & {
        [key: string]: string | boolean;
    }>, as?: string): ChainSelect<Record<string, any>>;
    select<R extends {} = Record<string, any>>(columns: Constructable<string | string[]>, as?: string): ChainSelect<R>;
    select<R extends {}>(columns: Constructable<{
        [key in keyof R]: boolean | string;
    } | string | string[]>, as?: string): ChainSelect<R>;
    // (undocumented)
    toSelect(): string;
    update(values: Constructable<{
        [key in keyof T]?: string;
    } | string>): ChainUpdate<T>;
}

// @public (undocumented)
class DbTableQuery<T extends TableType = Record<string, any>, C extends TableType = Partial<T>> extends DbTable<T> {
    constructor(name: string, statement: SqlValuesCreator);
    // (undocumented)
    insert(values: Constructable<UpdateRowValue<C> | UpdateRowValue<C>[]>): ChainInsert<T>;
    // (undocumented)
    insert(columns: string, values: Constructable<string>): ChainInsert<T>;
    updateFrom(values: Constructable<UpdateRowValue<T>>): ChainUpdate<T>;
}

// @public
interface DbTransaction extends DbQuery, AsyncDisposable {
    commit(): Promise<void>;
    rollback(): Promise<void>;
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
interface DeleteOption {
    // (undocumented)
    where?: Constructable<ConditionParam | void>;
}

// @public
function getObjectListKeys(objectList: any[], keepUndefinedKey?: boolean): Set<string>;

// @public
function having(conditions?: Constructable<ConditionParam | void>, type?: "AND" | "OR"): string;

// @public
type InferQueryResult<T> = T extends SqlStatementDataset<infer P> ? P : never;

// @public (undocumented)
type InferTableDefined<T extends TableDefined> = {
    [key in keyof T]: T[key] extends ColumnMeta<infer P> ? P : unknown;
};

// @public
type JsObjectMapSql = Map<new (...args: any[]) => any, SqlValueEncoder>;

// @public (undocumented)
type MultipleQueryResult = SingleQueryResult[];

// @public (undocumented)
type OrderBehavior = {
    key: string;
    asc: boolean;
    nullLast?: boolean;
};

// @public
function orderBy(by?: Constructable<OrderByParam | void>): string;

// @public (undocumented)
type OrderByParam = string | (string | OrderBehavior)[] | Record<string, boolean | `${OrderValue} ${"NULLS FIRST" | "NULLS LAST"}`>;

// @public (undocumented)
type OrderValue = "ASC" | "DESC";

// @public (undocumented)
class ParallelQueryError extends Error {
    constructor();
}

// @public
const pgSqlTransformer: JsObjectMapSql;

// @public @deprecated (undocumented)
type PickColumn<T extends {
    [key: string]: any;
}, Rq extends keyof T = keyof T, Pa extends Exclude<keyof T, Rq> = never> = {
    [key in Rq as null extends T[key] ? key : never]?: T[key];
} & {
    [key in Rq as null extends T[key] ? never : key]: T[key];
} & {
    [key in Pa]?: T[key];
};

// @public (undocumented)
type QueryResult = MultipleQueryResult | SingleQueryResult;

// @public (undocumented)
interface QueryRowsResult<T = any> extends SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows: T[];
}

// @public (undocumented)
function selectColumns(columns: Constructable<SelectParam>): string;

// @public (undocumented)
class Selection_2 {
    constructor(selectable: Constructable<SqlSelectable | string>, as?: string);
    // (undocumented)
    crossJoin(selectable: Constructable<SqlSelectable | string>, as?: string | undefined): Selection_2;
    // (undocumented)
    static from(selectable: Constructable<SqlSelectable | string>, as?: string): Selection_2;
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, as?: string): Selection_2;
    // (undocumented)
    fullJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    innerJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    leftJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    // (undocumented)
    naturalJoin(selectable: Constructable<SqlSelectable | string>, as?: string | undefined): Selection_2;
    // (undocumented)
    rightJoin(selectable: Constructable<SqlSelectable | string>, as: string | undefined, on: Constructable<ConditionParam>): Selection_2;
    select<T extends TableType = Record<string, any>>(columns: "*"): ChainSelect<T>;
    select(columns: Constructable<SelectParam>): ChainSelect<Record<string, any>>;
    select<T extends TableType>(columns: Constructable<{
        [key in keyof T]: string | boolean;
    } | string>): ChainSelect<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
type SelectParam = string | string[] | Record<string, string | boolean>;

// @public (undocumented)
interface SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows?: any[];
}

// @public
interface SqlSelectable {
    toSelect(): string;
}

// @public
class SqlSelectChain<T extends TableType> extends SqlTextStatementDataset<T> implements ChainSelect<T> {
    // (undocumented)
    groupBy(columns: string | string[]): ChainSelectAfterGroupBy<T>;
    // (undocumented)
    having(param?: Constructable<ConditionParam | void>): ChainSelectAfterHaving<T>;
    // (undocumented)
    limit(limit?: number, offset?: number): ChainSelectAfterLimit<T>;
    // (undocumented)
    orderBy(param?: Constructable<OrderByParam | void>): ChainSelectAfterOrderBy<T>;
    // (undocumented)
    where(param?: Constructable<ConditionParam | void>): ChainSelectAfterWhere<T>;
}

// @public (undocumented)
abstract class SqlStatement {
    abstract toString(): string;
}

// @public (undocumented)
abstract class SqlStatementDataset<T> extends SqlStatement implements SqlSelectable {
    toSelect(): string;
}

// @public (undocumented)
class SqlTextStatementDataset<T> extends SqlStatementDataset<T> {
    constructor(sql: string);
    // (undocumented)
    readonly sql: string;
    // (undocumented)
    toString(): string;
}

// @public
type SqlValueEncoder<T = any> = (this: SqlValuesCreator, value: T) => string;

// @public (undocumented)
type SqlValueFn = SqlValuesCreator & {
    (value: any, assertType?: AssertJsType): string;
};

// @public
class SqlValuesCreator {
    constructor(map?: JsObjectMapSql);
    // (undocumented)
    static create(map?: JsObjectMapSql): SqlValueFn;
    createValues<T extends {}>(asName: string, values: T[], valuesTypes: Record<string, string | {
        sqlType: string;
        sqlDefault?: string;
        assertJsType?: AssertJsType;
    }>): SqlStatementDataset<T>;
    // (undocumented)
    protected defaultObject(value: object): string;
    getClassType(value: object): undefined | (new (...args: unknown[]) => unknown);
    // @deprecated (undocumented)
    getObjectType(value: object): SqlValueEncoder;
    objectListToValuesList<T extends object>(objectList: T[], keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined | ColumnToValueConfig;
    }, keepUndefinedKey?: boolean): string;
    objectToValues<T extends object>(object: T, keys?: readonly (keyof T)[] | {
        [key in keyof T]?: string | undefined | ColumnToValueConfig;
    }): string;
    setTransformer(type: new (...args: any[]) => any, encoder?: SqlValueEncoder): void;
    // (undocumented)
    setTransformer(map: JsObjectMapSql): void;
    static string(value: string): string;
    toSqlStr(value: any, assertJsType?: AssertJsType): string;
    toValues(values: readonly any[]): string;
}

// @public (undocumented)
type StringLike = {
    toString(): string;
} | string;

// @public (undocumented)
type TableDefined = {
    [key: string]: ColumnMeta<any>;
};

// @public (undocumented)
type TableType = {
    [key: string]: any;
};

// @public
type ToInsertType<T extends {
    [key: string]: any;
}, Pa extends keyof T = never> = {
    [key in keyof T as key extends Pa ? never : null extends T[key] ? never : key]: T[key];
} & {
    [key in keyof T as null extends T[key] ? key : key extends Pa ? key : never]?: T[key];
};

// @public (undocumented)
type TransactionMode = "SERIALIZABLE" | "REPEATABLE READ" | "READ COMMITTED" | "READ UNCOMMITTED";

// @public (undocumented)
class TypeChecker<T> {
    constructor(map: Map<string, ColumnMeta<any>>);
    // (undocumented)
    check(value: {
        [key: string]: any;
    }): T;
    // (undocumented)
    checkList(value: any[]): T[];
}

// @public (undocumented)
type UpdateRowValue<T extends object> = {
    [key in keyof T]?: T[key] | String;
};

// @public
const v: SqlValueFn;

// @public
function where(conditions?: Constructable<ConditionParam | void>, type?: "AND" | "OR"): string;

// @public
class YourTable<T extends TableType = TableType, C extends TableType = T> extends DbTableQuery<T, C> {
    constructor(name: string, define: TableDefined, sqlValue: SqlValuesCreator);
    // (undocumented)
    readonly columns: readonly string[];
    // (undocumented)
    createTypeChecker<T>(keys: readonly string[]): TypeChecker<T>;
    // (undocumented)
    getColumnMeta(name: keyof T): ColumnMeta<unknown>;
}

// Warning: (ae-forgotten-export) The symbol "TypeMapDefined" needs to be exported by the entry point index.d.ts
//
// @public
class YourTypeMap<M extends TypeMapDefined> {
    constructor(typeMap?: M);
    // Warning: (ae-forgotten-export) The symbol "InferTypeMapDefined" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T extends TypeMapDefined>(rawTypeMap?: T): YourTypeMap<{
        [key in keyof T]: InferTypeMapDefined<T[key]>;
    }>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T][]>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T][] | null>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull: true, defaultValue?: string): ColumnMeta<T[]>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull?: boolean, defaultValue?: string): ColumnMeta<T[] | null>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T]>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T] | null>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull: true, defaultValue?: string): ColumnMeta<T>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull?: boolean, defaultValue?: string): ColumnMeta<T | null>;
}

// (No @packageDocumentation comment for this package)

```
