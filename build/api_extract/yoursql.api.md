## API Report File for "@asla/yoursql"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
type AssertJsType = "bigint" | "number" | "string" | "boolean" | "object" | (new (...args: any[]) => any);

// @public (undocumented)
interface ChainAfterConflict {
    // (undocumented)
    doNotThing(): ChainInsertReturning;
    // (undocumented)
    doUpdate(set: Constructable<string | string[] | Record<string, string>>): ChainInsertReturning;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
interface ChainCTE {
    // (undocumented)
    as(statement: Constructable<string>): ChainCTE;
    // (undocumented)
    as(name: string, statement: Constructable<string>): ChainCTE;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
interface ChainDelete extends ChainDeleteAfterUsing {
    // (undocumented)
    using(...table: (Constructable<string> | {
        selectable: Constructable<string>;
        as: string;
    })[]): ChainDeleteAfterUsing;
}

// @public (undocumented)
interface ChainDeleteAfterUsing extends ChainDeleteReturning {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainDeleteReturning;
}

// Warning: (ae-forgotten-export) The symbol "ChainModifyReturning" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ChainDeleteReturning extends ChainModifyReturning {
}

// @public (undocumented)
interface ChainInsert extends ChainInsertAfterValues {
    // (undocumented)
    select(statement: Constructable<string>): ChainInsertAfterValues;
    // (undocumented)
    values(statement: Constructable<string | string[]>): ChainInsertAfterValues;
}

// @public (undocumented)
interface ChainInsertAfterValues extends ChainInsertReturning {
    // (undocumented)
    onConflict(columns: string | string[]): ChainAfterConflict;
}

// @public (undocumented)
interface ChainInsertReturning extends ChainModifyReturning {
}

// @public (undocumented)
interface ChainSelect<T extends TableType> {
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, option?: SelectAsNameOption): ChainSelectAfterFirstFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterFirstFrom<T extends TableType> extends ChainSelectAfterFrom<T> {
    // (undocumented)
    from(selectable: Constructable<SqlSelectable | string>, option?: SelectAsNameOption): ChainSelectAfterFirstFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterFrom<T extends TableType> extends ChainSelectAfterJoin<T> {
    // (undocumented)
    crossJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectAsNameOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    fullJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    innerJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    leftJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    naturalJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectAsNameOption): ChainSelectAfterFrom<T>;
    // (undocumented)
    rightJoin(selectable: Constructable<SqlSelectable | string>, options?: SelectJoinOption): ChainSelectAfterFrom<T>;
}

// @public (undocumented)
interface ChainSelectAfterGroupBy<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    having(param: Constructable<ConditionParam | void>): ChainSelectAfterHaving<T>;
}

// @public (undocumented)
interface ChainSelectAfterHaving<T extends TableType> extends ChainSelectAfterOrderBy<T> {
    // (undocumented)
    orderBy(param: Constructable<OrderByParam | void>): ChainSelectAfterOrderBy<T>;
}

// @public (undocumented)
interface ChainSelectAfterJoin<T extends TableType> extends ChainSelectAfterWhere<T> {
    // (undocumented)
    where(param: Constructable<ConditionParam | void>): ChainSelectAfterWhere<T>;
}

// @public (undocumented)
interface ChainSelectAfterLimit<T extends TableType> extends SqlStatementDataset<T> {
}

// @public (undocumented)
interface ChainSelectAfterOrderBy<T extends TableType> extends SqlStatementDataset<T> {
    // (undocumented)
    limit(limit?: number | bigint, offset?: number | bigint): ChainSelectAfterLimit<T>;
}

// @public (undocumented)
interface ChainSelectAfterWhere<T extends TableType> extends ChainSelectAfterHaving<T> {
    // (undocumented)
    groupBy(columns?: string | string[]): ChainSelectAfterGroupBy<T>;
}

// @public (undocumented)
interface ChainUpdate<T extends TableType = TableType> {
    // (undocumented)
    set(value: Constructable<{
        [key in keyof T]?: string;
    } | string>): ChainUpdateAfterSet;
}

// @public (undocumented)
interface ChainUpdateAfterForm extends ChainUpdateReturning {
    // (undocumented)
    where(where: Constructable<ConditionParam | void>): ChainUpdateReturning;
}

// @public (undocumented)
interface ChainUpdateAfterSet extends ChainUpdateAfterForm {
    // (undocumented)
    from(...table: (Constructable<string> | {
        selectable: Constructable<string>;
        as: string;
    })[]): ChainUpdateAfterForm;
}

// @public (undocumented)
interface ChainUpdateReturning extends ChainModifyReturning {
}

declare namespace client {
    export {
        ParallelQueryError,
        ConnectionNotAvailableError,
        DbConnection,
        TransactionMode,
        DbTransaction,
        DbQueryPool,
        SqlLike,
        sqlLikeToString,
        SingleQueryResult,
        QueryRowsResult,
        MultipleQueryResult,
        QueryResult,
        DbQueryBase,
        DbQuery,
        DbCursorOption,
        DbCursor,
        DbPoolConnection,
        DbPoolTransactionOption,
        DbPoolTransaction
    }
}

// @public
class ColumnMeta<T> {
    constructor(type: CustomDbType<T> | (new (...args: any[]) => T),
    sqlType: string,
    notNull?: boolean,
    isArray?: boolean,
    sqlDefault?: string | undefined);
    checkValue(value: any): boolean;
    readonly isArray: boolean;
    readonly notNull: boolean;
    readonly sqlDefault?: string | undefined;
    readonly sqlType: string;
    // (undocumented)
    readonly type: CustomDbType<T> | (new (...args: any[]) => T);
}

// @public (undocumented)
type ColumnToValueConfig = {
    sqlType?: string;
    assertJsType?: AssertJsType;
};

// @public (undocumented)
type ConditionParam = string | string[];

// @public (undocumented)
class ConnectionNotAvailableError extends Error {
    constructor(message: string);
}

// @public (undocumented)
type Constructable<T> = T | (() => T);

declare namespace core {
    export {
        v,
        pgSqlTransformer,
        JsObjectMapSql,
        SqlValueEncoder,
        SqlValueFn,
        SqlValuesCreator,
        AssertJsType,
        SqlValueData,
        ColumnToValueConfig,
        ObjectToValueKeys,
        SqlStatement,
        SqlSelectable,
        SqlStatementDataset,
        SqlTextStatementDataset,
        InferQueryResult,
        SqlTemplate,
        select,
        orderBy,
        SelectAsNameOption,
        ChainSelect,
        ChainSelectAfterFirstFrom,
        SelectJoinOption,
        ChainSelectAfterFrom,
        ChainSelectAfterJoin,
        ChainSelectAfterWhere,
        ChainSelectAfterGroupBy,
        ChainSelectAfterHaving,
        ChainSelectAfterOrderBy,
        ChainSelectAfterLimit,
        OrderValue,
        OrderBehavior,
        OrderByParam,
        insertInto,
        ChainAfterConflict,
        ChainInsert,
        ChainInsertAfterValues,
        ChainInsertReturning,
        update,
        UpdateOption,
        ChainUpdate,
        ChainUpdateAfterSet,
        ChainUpdateAfterForm,
        ChainUpdateReturning,
        deleteFrom,
        DeleteOption,
        ChainDelete,
        ChainDeleteAfterUsing,
        ChainDeleteReturning,
        withAs,
        withRecursiveAs,
        ChainCTE,
        selectColumns,
        ConditionParam,
        Constructable,
        SelectParam,
        ToInsertType,
        UpdateRowValue,
        TableType,
        TypeChecker,
        ColumnMeta,
        YourTypeMap,
        CustomDbType,
        TableDefined,
        InferTableDefined,
        YourTable
    }
}

// @public
class CustomDbType<T> {
    constructor(is: (this: CustomDbType<T>, value: any) => boolean, name: string);
    // (undocumented)
    static readonly bigint: CustomDbType<bigint>;
    // (undocumented)
    static readonly boolean: CustomDbType<boolean>;
    // (undocumented)
    readonly is: (this: CustomDbType<T>, value: any) => boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly number: CustomDbType<number>;
    // (undocumented)
    static readonly string: CustomDbType<string>;
}

// @public
interface DbConnection extends DbQuery, AsyncDisposable {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
abstract class DbCursor<T> {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    // (undocumented)
    [Symbol.asyncIterator](): AsyncGenerator<T, undefined, void>;
    abstract close(): Promise<void>;
    abstract read(maxSize?: number): Promise<T[]>;
}

// @public (undocumented)
interface DbCursorOption {
    // (undocumented)
    defaultSize?: number;
}

// @public
class DbPoolConnection extends DbQuery {
    // (undocumented)
    [Symbol.dispose](): void;
    constructor(conn: DbQueryBase, onRelease: (conn: DbQueryBase) => void);
    // (undocumented)
    begin(mode?: TransactionMode): Promise<void>;
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    // (undocumented)
    query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T = any>(sql: SqlLike): Promise<QueryRowsResult<T>>;
    release(): void;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
}

// @public
class DbPoolTransaction extends DbQuery implements DbTransaction {
    // (undocumented)
    [Symbol.asyncDispose](): Promise<void>;
    constructor(connect: () => Promise<DbPoolConnection>, option?: TransactionMode | DbPoolTransactionOption);
    // (undocumented)
    commit(): Promise<void>;
    // (undocumented)
    readonly mode?: TransactionMode;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlStatementDataset<T>): Promise<T>;
    // (undocumented)
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    // (undocumented)
    query<T extends object = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    // (undocumented)
    query<T extends object = any>(sql: SqlLike): Promise<QueryRowsResult<T>>;
    // (undocumented)
    get released(): boolean;
    // (undocumented)
    rollback(): Promise<void>;
    // (undocumented)
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
type DbPoolTransactionOption = {
    errorRollback?: boolean;
    mode?: TransactionMode;
};

// @public
abstract class DbQuery implements DbQueryBase {
    // (undocumented)
    abstract multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    multipleQueryRows<T extends any[] = any[]>(sql: SqlLike | SqlLike[]): Promise<T[]>;
    // (undocumented)
    abstract query<T = any>(sql: SqlLike): Promise<QueryRowsResult<T>>;
    queryCount(sql: SqlLike): Promise<number>;
    queryFirstRow<T = any>(sql: SqlStatementDataset<T>): Promise<T>;
    // (undocumented)
    queryFirstRow<T = any>(sql: SqlLike): Promise<T>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: SqlStatementDataset<T>, key: K): Promise<Map<T[K], T>>;
    queryMap<T extends Record<string, any> = Record<string, any>, K extends keyof T = string>(sql: SqlLike, key: K): Promise<Map<T[K], T>>;
    queryRows<T = any>(sql: SqlStatementDataset<T>): Promise<T[]>;
    queryRows<T = any>(sql: SqlLike): Promise<T[]>;
}

// @public (undocumented)
interface DbQueryBase {
    multipleQuery<T extends MultipleQueryResult = MultipleQueryResult>(sql: SqlLike | SqlLike[]): Promise<T>;
    query<T = any>(sql: SqlStatementDataset<T>): Promise<QueryRowsResult<T>>;
    query<T = any>(sql: SqlLike): Promise<QueryRowsResult<T>>;
}

// @public
interface DbQueryPool extends DbQuery {
    // (undocumented)
    begin(mode?: TransactionMode): DbTransaction;
    // (undocumented)
    connect(): Promise<DbPoolConnection>;
    // (undocumented)
    cursor<T extends {}>(sql: SqlStatementDataset<T>): Promise<DbCursor<T>>;
    // (undocumented)
    cursor<T>(sql: SqlLike, option?: DbCursorOption): Promise<DbCursor<T>>;
    // (undocumented)
    idleCount: number;
    // (undocumented)
    totalCount: number;
}

// @public
interface DbTransaction extends DbQuery, AsyncDisposable {
    commit(): Promise<void>;
    rollback(): Promise<void>;
    rollbackTo(savePoint: string): Promise<void>;
    // (undocumented)
    savePoint(savePoint: string): Promise<void>;
}

// @public (undocumented)
function deleteFrom(table: string, option?: DeleteOption): ChainDelete;

// @public (undocumented)
interface DeleteOption {
    // (undocumented)
    asName?: string;
}

// @public
type InferQueryResult<T> = T extends SqlStatementDataset<infer P> ? P : never;

// @public (undocumented)
type InferTableDefined<T extends TableDefined> = {
    [key in keyof T]: T[key] extends ColumnMeta<infer P> ? P : unknown;
};

// @public (undocumented)
function insertInto(target: string): ChainInsert;

// @public (undocumented)
function insertInto(table: string, columns: string[]): ChainInsert;

// @public
type JsObjectMapSql = Map<new (...args: any[]) => any, SqlValueEncoder>;

// @public (undocumented)
type MultipleQueryResult = SingleQueryResult[];

// @public (undocumented)
type ObjectToValueKeys<T extends {}> = readonly (keyof T)[] | {
    [key in keyof T]?: string | undefined | ColumnToValueConfig;
};

// @public (undocumented)
type OrderBehavior = {
    key: string;
    asc: boolean;
    nullLast?: boolean;
    target?: undefined;
} | {
    key: string;
    target: OrderByValue;
};

// @public
function orderBy(by?: Constructable<OrderByParam | void>): string;

// @public (undocumented)
type OrderByParam = string | OrderBehavior | (string | OrderBehavior)[];

// @public (undocumented)
type OrderValue = "ASC" | "DESC";

// @public (undocumented)
class ParallelQueryError extends Error {
    constructor();
}

// @public
const pgSqlTransformer: JsObjectMapSql;

// @public (undocumented)
type QueryResult = MultipleQueryResult | SingleQueryResult;

// @public (undocumented)
interface QueryRowsResult<T = any> extends SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows: T[];
}

// @public (undocumented)
function select(columns?: undefined | ""): ChainSelect<{}>;

// @public (undocumented)
function select<T extends TableType>(columns: "*"): ChainSelect<T>;

// @public (undocumented)
function select<T extends TableType>(columns: Constructable<{
    [key in keyof T]: string | boolean;
}>): ChainSelect<T>;

// @public (undocumented)
function select<T extends TableType>(columns: Constructable<string | string[]>): ChainSelect<T>;

// @public (undocumented)
function select<T extends TableType>(columns: Constructable<string | string[] | {
    [key in keyof T]: string | boolean;
}>): ChainSelect<T>;

// @public (undocumented)
type SelectAsNameOption = {
    as?: string;
};

// @public (undocumented)
function selectColumns(columns: Constructable<SelectParam>): string;

// @public (undocumented)
type SelectJoinOption = SelectAsNameOption & {
    on?: Constructable<ConditionParam>;
};

// @public (undocumented)
type SelectParam = string | string[] | Record<string, string | boolean>;

// @public (undocumented)
interface SingleQueryResult {
    // (undocumented)
    rowCount: number;
    // (undocumented)
    rows?: any[];
}

// @public (undocumented)
type SqlLike = {
    genSql(): string;
} | string;

// @public (undocumented)
function sqlLikeToString(sqlLike: SqlLike): string;

// @public
interface SqlSelectable {
    toSelect(asName?: string): string;
}

// @public (undocumented)
abstract class SqlStatement {
    abstract genSql(): string;
    toString(): string;
}

// @public (undocumented)
abstract class SqlStatementDataset<T> extends SqlStatement implements SqlSelectable {
    toSelect(asName?: string): string;
}

// @public (undocumented)
interface SqlTemplate {
    // (undocumented)
    genSql(): string;
    // (undocumented)
    readonly templates: readonly string[];
    // (undocumented)
    toTextTemplate(): {
        text: string;
        values: string[];
    };
    // (undocumented)
    readonly values: readonly unknown[];
}

// @public (undocumented)
class SqlTextStatementDataset<T> extends SqlStatementDataset<T> {
    constructor(sql: string);
    // (undocumented)
    genSql(): string;
    // (undocumented)
    readonly sql: string;
}

// @public (undocumented)
type SqlValueData = {
    columns: readonly string[];
    text: string;
};

// @public
type SqlValueEncoder<T = any> = (this: SqlValuesCreator, value: T) => string;

// @public (undocumented)
type SqlValueFn = SqlValuesCreator & {
    (value: any, assertType?: AssertJsType): string;
};

// @public
class SqlValuesCreator {
    constructor(map?: JsObjectMapSql);
    // (undocumented)
    static create(map?: JsObjectMapSql): SqlValueFn;
    createValues<T extends {}>(asName: string, values: T[], valuesTypes: Record<string, string | {
        sqlType: string;
        sqlDefault?: string;
        assertJsType?: AssertJsType;
    }>): SqlStatementDataset<T>;
    // (undocumented)
    protected defaultObject(value: object): string;
    // @alpha (undocumented)
    gen(split: TemplateStringsArray, ...values: any[]): SqlTemplate;
    getClassType(value: object): undefined | (new (...args: unknown[]) => unknown);
    objectListToValues<T extends object>(objectList: T[], keys?: ObjectToValueKeys<T>, keepUndefinedKey?: boolean): SqlValueData;
    // @deprecated (undocumented)
    objectListToValuesList<T extends object>(objectList: T[], keys?: ObjectToValueKeys<T>, keepUndefinedKey?: boolean): string;
    objectToValue<T extends object>(object: T, keys?: ObjectToValueKeys<T>): SqlValueData;
    // @deprecated (undocumented)
    objectToValues<T extends object>(object: T, keys?: ObjectToValueKeys<T>): string;
    setTransformer(type: new (...args: any[]) => any, encoder?: SqlValueEncoder): void;
    // (undocumented)
    setTransformer(map: JsObjectMapSql): void;
    static string(value: string): string;
    toSqlStr(value: any, assertJsType?: AssertJsType): string;
    toValues(values: readonly any[]): string;
}

// @public (undocumented)
type TableDefined = {
    [key: string]: ColumnMeta<any>;
};

// @public (undocumented)
type TableType = {
    [key: string]: any;
};

// @public
type ToInsertType<T extends {
    [key: string]: any;
}, Pa extends keyof T = never> = {
    [key in keyof T as key extends Pa ? never : null extends T[key] ? never : key]: T[key];
} & {
    [key in keyof T as null extends T[key] ? key : key extends Pa ? key : never]?: T[key];
};

// @public (undocumented)
type TransactionMode = "SERIALIZABLE" | "REPEATABLE READ" | "READ COMMITTED" | "READ UNCOMMITTED";

// @public (undocumented)
class TypeChecker<T> {
    constructor(map: Map<string, ColumnMeta<any>>);
    // (undocumented)
    check(value: {
        [key: string]: any;
    }): T;
    // (undocumented)
    checkList(value: any[]): T[];
}

// @public (undocumented)
function update<T extends TableType>(table: string, options?: UpdateOption): ChainUpdate<T>;

// @public (undocumented)
interface UpdateOption {
    // (undocumented)
    asName?: string;
}

// @public (undocumented)
type UpdateRowValue<T extends object> = {
    [key in keyof T]?: T[key] | String;
};

// @public
const v: SqlValueFn;

// @public (undocumented)
function withAs(statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withAs(name: string, statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withRecursiveAs(statement: Constructable<string>): ChainCTE;

// @public (undocumented)
function withRecursiveAs(name: string, statement: Constructable<string>): ChainCTE;

// @public
class YourTable<T extends TableType = TableType> {
    constructor(name: string, define: TableDefined);
    // (undocumented)
    readonly columns: readonly string[];
    // (undocumented)
    createTypeChecker<T>(keys: readonly string[]): TypeChecker<T>;
    // (undocumented)
    getColumnMeta(name: keyof T): ColumnMeta<unknown>;
    // (undocumented)
    readonly name: string;
}

// Warning: (ae-forgotten-export) The symbol "TypeMapDefined" needs to be exported by the entry point index.d.ts
//
// @public
class YourTypeMap<M extends TypeMapDefined> {
    constructor(typeMap?: M);
    // Warning: (ae-forgotten-export) The symbol "InferTypeMapDefined" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T extends TypeMapDefined>(rawTypeMap?: T): YourTypeMap<{
        [key in keyof T]: InferTypeMapDefined<T[key]>;
    }>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T][]>;
    // (undocumented)
    genArrColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T][] | null>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull: true, defaultValue?: string): ColumnMeta<T[]>;
    // (undocumented)
    genArrColumn<T>(type: keyof M, notNull?: boolean, defaultValue?: string): ColumnMeta<T[] | null>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull: true, defaultValue?: string): ColumnMeta<M[T]>;
    // (undocumented)
    genColumn<T extends keyof M>(type: T, noNull?: boolean, defaultValue?: string): ColumnMeta<M[T] | null>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull: true, defaultValue?: string): ColumnMeta<T>;
    // (undocumented)
    genColumn<T>(type: keyof M, noNull?: boolean, defaultValue?: string): ColumnMeta<T | null>;
}

// Warnings were encountered during analysis:
//
// src/sql_gen/statement/select_chain.ts:99:20 - (ae-forgotten-export) The symbol "OrderByValue" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
